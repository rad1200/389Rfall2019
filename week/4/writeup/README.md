# Writeup 2 - Pentesting

Name: Radhika Khare
Section: 0101

I pledge on my honor that I have not given or received any unauthorized assistance on this assignment or examination.

Digital acknowledgement: Radhika Khare

## Assignment Writeup

### Part 1 (45 pts)

The flag is CMSC389R- {p1ng_as_a_$erv1c3} found in the flag.txt directory of the home folder. After doing the nc wattsamp.net 1337 command when the prompt says enter the ip address I first did 157.230.179.99; ls. This command I injected allowed me to ping the server then get a listing of the files in that system. From there I saw there was a home folder I wanted to check out so I did the nc command again at the prompt I did 157.230.179.99; ls ./home. The command showed me that there was a file called flag.txt (also part of the reason I looked at the home folder first was homework 2). I repeated doing the nc command once again and the at the prompt entered 157.230.179.99;cat ./home/flag.txt. Basically at the prompt I would enter the expected value of an ip then a semicolon and then the command I wanted to run, thus executing the command I wanted. The semicolon is a command separator that works with unix based system like the wattsamp server. One thing I realized while working on part 2 is that technically I could not give an ip and just enter the command I want to inject using ;cmd. In fact doing so is more efficient as it avoids the time latency of having to execute the ping command first before doing the desired command. By doing ;cmd (where cmd is the command I want to enter) instead I am able to fail out of the execution of ping and then immediately run the command desired. It's important that I precede the command desired with the ; because otherwise it believes I'm trying to enter cmd as input for the ping function rather than run the command itself. The whole reason why I was able to do this exploit of command injection was because the server passes unchecked and unsafe user input into the unix shell so while they were expecting a ping related input (IP/hostname) it allowed for arbitrary unix commands to be injected. Additionally it's important to note that I can enter multiple commands at a time (when finding the flag I hadn't but I utilized this idea for part 2) so when the prompt is given to me to enter ip I can enter something like ;cmd1;cmd2;cmd3 etc. One way Eric Norman can avoid the exploit is by avoiding command line calls like ping all together. Utilizing shell commands without proper limitations on what users can enter opens the command injection vulnerability like it did for Norman. In the case that he really does want the ping to execute but nothing else he could have a check in his program for characters commonly used in command injections like ";","|" and "&" and have the input either be rejected or removed of such characters (parsing through the string input). Especially in the case of ping it's unlikely the input would include one of those malicious characters as it takes in a hostname or IP. To be even tighter on restrictions he can add checks for certain commands that he wants to restrict and make sure the user doesn't enter it (by parsing through string input).
### Part 2 (55 pts)

For part 2 I created a "shell within a shell" sort of situation. I recognize that I have steps that are unnecessary or redundant but I have not gotten a chance to refine my code to be extremely efficient. Also my shell has some extra spacing after certain commands so it doesn't look perfect. That being said I started off in main by defining a variable for usr input. Then I set my outer shell to work by having a while loop that runs again and again. It is an infinite loop but the quit function will get us out of there. The following steps are defined in this while loop. I created a socket connection as the pull functionality requires socket connections. I created the prompt to be ">" because as long as you are in the outer shell that's the prompt. From there I collect user input which could be one or more strings. Of the 4 commands to look at (shell,pull,help,quit) there are different requirements of the valid of the argument to be valid so I check for that within each check for command. If the usr input is a shell command, I check if the length of the command is right (which if not reuslts in the instruction list) and if it is I create my inner shell. In the inner shell I stay within the shell as long as the command entered is not exit (my while loop condition). Globally I have a variable defined (note that I realize the variable doesn't have to be gloablly defined but I didn't feel like passing the variable around) that will keep track of any cd path changes called path_cd which is originally initalized to root (/). Within the shell I set the prompt to be the path that may have be cded to somewhere besides root in a previous command in the shell. Whatever user input I get within shell mood gets executed in the execute_cmd function. Back to the outer shell, I get a help command of right (or wrong) length I print out the menu. With the pull command I connect to the socket then I cat the file in the remote path (doing ;cat remote_path) then change the output so that it writes to the local path print the contents of the file from the remote path (what I cat) then I change back the stdout to be in terminal. The quit command if it's of proper length (note by proper length I mean number of arguments) I exit the python script. In the execute_cmd function I connect to the socket. I recieve the prompt and then send ;cd path_cd;cmd because the command could rely on where I have cded to in the past and we know that with each new socket connection it resets the current directory to be root. Then once I have changed directories correctly once I execute the cd to the path it should be in the command will run based on that. The next part of my code has some redundant actions from what's been done already in execute_cmd. In this part I check if the command given is cd. If it is then I create a new socket connection, cd into the correct path according to path_cd, then cd according the the command given in execute_cmd, and THEN I do pwd so I can ge tthe current working directory after the cd has been executed and updated path_cd variable. In retrospect I recognize there is more efficient ways to do my code that could have helped to avoid some of the extra spaces (which directly result from unnecessary actions with a new socket connection.
