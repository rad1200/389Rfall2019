# Writeup 10 - Crypto I

Name: Radhika Khare
Section: 0101

I pledge on my honor that I have not given or received any unauthorized assistance on this assignment or examination.

Digital acknowledgement: Radhika Khare


## Assignment details

### Part 1 (45 Pts)
1. The ledger file consists of the key hash, ciphertext hash, initialization vector, and the cipher text itself. The byte offsets are 16 bytes each for the key_hash, ctext_hash, and initialization vector. The cipher text length is size of the file bytes minus 48 bytes of the other stuff mentioned before.
2. It utilizes md5hash and aes128. While a hash cannot be decrypted there are inevitable collisions which make it possible to crack a hash. Md5 is particularly prone to brute force attacks. Generally SHA is considered more secure than md5 due to the fact that people haven't "broken" it yet and it has longer bit outputs. Aes128 is a block cipher and is reversible with knowledge of the key. Aes128 takes a 16 byte key which is less bytes than the 32 bytes SHA256 takes in which makes Aes128 less secure than it. It is reasonable to say that the double hashing does make it a little more secure than just hashing once especially considering the aes128 hash was done before the md5 hash (because now an attacker has to crack the md5 before they can get to the key to reverse aes128 (if thats within their capabiliities)
3. The binary file when converting the hex to ascii is written with all these special ascii characters. None of the initial hex values matched any known magic numbers for a file. I cannot currently tell anything else.
4. To ensure confedentiality messages are encrypted before being written to the file. The encryption key is derived using aes_encrypt() (aes128 hashing) which takes in cipher_params struct and the address of the ctext variable and then md5 hashing the pointer itself and the value derived from aes_encrypt(). 
5. It checks integrity by seeing if hash in file is as expected by using memcmp to compare the cipher test once hashed with the cipher text's hash in the ledger. 
6.
7. The initialization vector was generated by randomly generating 16 bytes (this ensures non-reusage of the iv)
### Part 2 (45 Pts)
note that the key hash is 2 bytes. brute force random strings comparing with the md5 hash (can assume its alphabet, upper case)
### Part 3 (10 Pts)

