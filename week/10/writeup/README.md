# Writeup 10 - Crypto I

Name: Radhika Khare
Section: 0101

I pledge on my honor that I have not given or received any unauthorized assistance on this assignment or examination.

Digital acknowledgement: Radhika Khare


## Assignment details

### Part 1 (45 Pts)
1. The ledger file consists of the key hash, ciphertext hash, initialization vector, and the cipher text itself. The byte offsets are 16 bytes each for the key hash (bytes 0-16), ciphertext hash (16-32), and initialization vector (32-48). The cipher text length is size of the file bytes minus 48 bytes of the other stuff mentioned before.
2. It utilizes md5 and aes128. While a hash cannot be decrypted there are inevitable collisions which make it possible to crack a hash. Md5 is particularly prone to brute force attacks. Generally SHA is considered more secure than md5 due to the fact that people haven't "broken" it yet and it has longer bit outputs. Aes128 is a block cipher and is reversible with knowledge of the key. Aes128 takes a 16 byte key which is less bytes than the 32 bytes SHA256 takes in which makes Aes128 less secure than it. It is reasonable to say that the double hashing does make it a little more secure than just hashing once especially considering the aes128 hash was done before the md5 hash (because now an attacker has to crack the md5 before they can get to the key to reverse aes128 (if thats within their capabiliities).
3. The binary file when converting the hex to ascii is written with all these special ascii characters. I don't know if this is important but the file size is 656 bytes (at least if you look at the file size in file explorer's properties feature) so I believe the cipher text would be 656-48 bytes (the 48 bytes comes from what i explained in 1)
4. To ensure confedentiality messages are encrypted before being written to the file. It's encrypted using aes128_encrypt() (aes128 hashing) which takes in cipher_params struct and the address of the cipher text and then md5 hashing the cipher text pointer and the value derived from aes128_encrypt(). The encryption key itself is the 2 byte key (the rest of the 14 bytes in address space are in fact 0) that is taken in as a command line argument
5. Integrity is checked by making sure the cipher text hash in the ledger file matches the cipher text hash correctly. It checks integrity by seeing if hash in file is as expected by using memcmp to compare the cipher text once hashed with the cipher text's hash in the ledger. Because the hash itself can be modified to match the hash of the modified cipher text, it doesn't matter that the hash is stored in the ledger file thus making this integrity check flawed.
6. Authenticity is checked by checking the equality of the key hash in the ledger with the key once hashed. This is done by doing memcmp to compare the key once hashed with the key's hash in the ledger file. The key (password) being only 2 bytes essentially can be cracked through brute force
7. The initialization vector was generated by randomly generating 16 bytes (this ensures non-reusage of the iv)
### Part 2 (45 Pts)
note that the key hash is 2 bytes. brute force random strings comparing with the md5 hash (can assume its alphabet, upper case)
### Part 3 (10 Pts) 
I think the concept of security through obscurity sounds a little too subjective to be a reliable especially as the only means of security (like how would you know you have maintained enough secrecy in design/implementation). If you haven't obfuscated in enough anyone who figures out what was done they can expose it and then the security is completely broken down. From what I have researched it is not considered reliable and is definitely not usually endorsed by those in the field. Kerchhoff's principle doesn't make any assumptions and doesn't rely on hoping and is a more risk based approach to cyberattacks as it states that a cryptographic system should be secure even if everything besides the key is public knowledge. While there's a general consensus that security through obscurity is not ideal, the principle has been used with Onion (Tor) routing which we briefly talked about in class which could be interpreted as a counterpoint to my argument as the technique is still utilized. That being said like with many things that utilize security through obscurity it has be proven to have been broken before through 2 techniques ("timing analysis" and "exit node vulnerability" according to wikipedia) which really proves that which security through obscurity is still being utilized in designs/implementations, vulnerabilites do get found out (I would presume onion routing is still utilized because the vulnerabilites are either not easy to exploit or aren't super well know though wikipedia had the 2 techniques so it's really one wikipedia search away to know that the onion routing scheme is breakable)
